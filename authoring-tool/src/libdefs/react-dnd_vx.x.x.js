// @flow

/**
 * Flowtype definitions for interfaces
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.14.1
 */

declare module "react-dnd" {
  declare export type Identifier = string | Symbol;
  declare export type SourceType = Identifier;
  declare export type TargetType = Identifier | Identifier[];
  declare export type Unsubscribe = () => void;
  declare export type Listener = () => void;
  declare export type XYCoord = {
    x: number,
    y: number,
  };

  declare export var HandlerRole: {|
    +SOURCE: "SOURCE", // "SOURCE"
    +TARGET: "TARGET", // "TARGET"
  |};
  declare export type Backend = {
    setup(): void,
    teardown(): void,
    connectDragSource(sourceId: any, node?: any, options?: any): Unsubscribe,
    connectDragPreview(sourceId: any, node?: any, options?: any): Unsubscribe,
    connectDropTarget(targetId: any, node?: any, options?: any): Unsubscribe,
    profile(): { [key: string]: number, ... },
  };
  declare export type DragDropMonitor = {
    subscribeToStateChange(
      listener: Listener,
      options?: {
        handlerIds: Identifier[] | void,
        ...
      }
    ): Unsubscribe,
    subscribeToOffsetChange(listener: Listener): Unsubscribe,
    canDragSource(sourceId: Identifier | void): boolean,
    canDropOnTarget(targetId: Identifier | void): boolean,

    /**
     * Returns true if a drag operation is in progress, and either the owner initiated the drag, or its isDragging()
     * is defined and returns true.
     */
    isDragging(): boolean,
    isDraggingSource(sourceId: Identifier | void): boolean,
    isOverTarget(
      targetId: Identifier | void,
      options?: {
        shallow?: boolean,
        ...
      }
    ): boolean,

    /**
     * Returns a string or a symbol identifying the type of the current dragged item. Returns null if no item is being dragged.
     */
    getItemType(): Identifier | null,

    /**
     * Returns a plain object representing the currently dragged item. Every drag source must specify it by returning an object
     * from its beginDrag() method. Returns null if no item is being dragged.
     */
    getItem(): any,
    getSourceId(): Identifier | null,
    getTargetIds(): Identifier[],

    /**
     * Returns a plain object representing the last recorded drop result. The drop targets may optionally specify it by returning an
     * object from their drop() methods. When a chain of drop() is dispatched for the nested targets, bottom up, any parent that
     * explicitly returns its own result from drop() overrides the child drop result previously set by the child. Returns null if
     * called outside endDrag().
     */
    getDropResult(): any,

    /**
     * Returns true if some drop target has handled the drop event, false otherwise. Even if a target did not return a drop result,
     * didDrop() returns true. Use it inside endDrag() to test whether any drop target has handled the drop. Returns false if called
     * outside endDrag().
     */
    didDrop(): boolean,
    isSourcePublic(): boolean | null,

    /**
     * Returns the { x, y } client offset of the pointer at the time when the current drag operation has started.
     * Returns null if no item is being dragged.
     */
    getInitialClientOffset(): XYCoord | null,

    /**
     * Returns the { x, y } client offset of the drag source component's root DOM node at the time when the current drag
     * operation has started. Returns null if no item is being dragged.
     */
    getInitialSourceClientOffset(): XYCoord | null,

    /**
     * Returns the last recorded { x, y } client offset of the pointer while a drag operation is in progress.
     * Returns null if no item is being dragged.
     */
    getClientOffset(): XYCoord | null,

    /**
     * Returns the projected { x, y } client offset of the drag source component's root DOM node, based on its position at the time
     * when the current drag operation has started, and the movement difference. Returns null if no item is being dragged.
     */
    getSourceClientOffset(): XYCoord | null,

    /**
     * Returns the { x, y } difference between the last recorded client offset of the pointer and the client offset when the current
     * drag operation has started. Returns null if no item is being dragged.
     */
    getDifferenceFromInitialOffset(): XYCoord | null,
  };
  declare type InternalDragSource = {
    beginDrag(monitor: DragDropMonitor, targetId: Identifier): void,
    endDrag(monitor: DragDropMonitor, targetId: Identifier): void,
    canDrag(monitor: DragDropMonitor, targetId: Identifier): boolean,
    isDragging(monitor: DragDropMonitor, targetId: Identifier): boolean,
  };
  declare type InternalDropTarget = {
    canDrop(monitor: DragDropMonitor, targetId: Identifier): boolean,
    hover(monitor: DragDropMonitor, targetId: Identifier): void,
    drop(monitor: DragDropMonitor, targetId: Identifier): any,
  };
  declare type HandlerRegistry = {
    addSource(type: SourceType, source: InternalDragSource): Identifier,
    addTarget(type: TargetType, target: InternalDropTarget): Identifier,
    containsHandler(handler: InternalDragSource | InternalDropTarget): boolean,
    getSource(
      sourceId: Identifier,
      includePinned?: boolean
    ): InternalDragSource,
    getSourceType(sourceId: Identifier): SourceType,
    getTargetType(targetId: Identifier): TargetType,
    getTarget(targetId: Identifier): InternalDropTarget,
    isSourceId(handlerId: Identifier): boolean,
    isTargetId(handlerId: Identifier): boolean,
    removeSource(sourceId: Identifier): void,
    removeTarget(targetId: Identifier): void,
    pinSource(sourceId: Identifier): void,
    unpinSource(): void,
  };
  declare export type Action<Payload> = {
    type: Identifier,
    payload: Payload,
  };
  declare export type SentinelAction = {
    type: Identifier,
  };
  declare export type ActionCreator<Payload> = (args: any[]) => Action<Payload>;
  declare export type BeginDragOptions = {
    publishSource?: boolean,
    clientOffset?: XYCoord,
    getSourceClientOffset?: (sourceId: Identifier) => XYCoord,
  };
  declare export type InitCoordsPayload = {
    clientOffset: XYCoord | null,
    sourceClientOffset: XYCoord | null,
  };
  declare export type BeginDragPayload = {
    itemType: Identifier,
    item: any,
    sourceId: Identifier,
    clientOffset: XYCoord | null,
    sourceClientOffset: XYCoord | null,
    isSourcePublic: boolean,
  };
  declare export type HoverPayload = {
    targetIds: Identifier[],
    clientOffset: XYCoord | null,
  };
  declare export type HoverOptions = {
    clientOffset?: XYCoord,
  };
  declare export type DropPayload = {
    dropResult: any,
  };
  declare export type TargetIdPayload = {
    targetId: Identifier,
  };
  declare export type SourceIdPayload = {
    sourceId: Identifier,
  };
  declare export type DragDropActions = {
    beginDrag(
      sourceIds?: Identifier[],
      options?: any
    ): Action<BeginDragPayload> | void,
    publishDragSource(): SentinelAction | void,
    hover(targetIds: Identifier[], options?: any): Action<HoverPayload>,
    drop(options?: any): void,
    endDrag(): SentinelAction,
  };
  declare export type DragDropManager = {
    getMonitor(): DragDropMonitor,
    getBackend(): Backend,
    getRegistry(): HandlerRegistry,
    getActions(): DragDropActions,
    dispatch(action: any): void,
  };
  declare export type BackendFactory = (
    manager: DragDropManager,
    globalContext?: any,
    configuration?: any
  ) => Backend;

  declare export function createDragDropManager(
    backendFactory: BackendFactory,
    globalContext?: mixed,
    backendOptions?: mixed,
    debugMode?: boolean
  ): DragDropManager;

  declare export type HandlerManager = {
    receiveHandlerId: (handlerId: Identifier | null) => void,
    getHandlerId: () => Identifier | null,
  };
  declare export type DragSourceMonitor<
    DragObject = mixed,
    DropResult = mixed
  > = {
    ...$Exact<HandlerManager>,
    ...$Exact<MonitorEventEmitter>,

    /**
     * Returns true if no drag operation is in progress, and the owner's canDrag() returns true or is not defined.
     */
    canDrag(): boolean,

    /**
     * Returns true if a drag operation is in progress, and either the owner initiated the drag, or its isDragging() is defined and returns true.
     */
    isDragging(): boolean,

    /**
     * Returns a string or a symbol identifying the type of the current dragged item. Returns null if no item is being dragged.
     */
    getItemType(): Identifier | null,

    /**
     * Returns a plain object representing the currently dragged item. Every drag source must specify it by returning an object from its beginDrag() method.
     * Returns null if no item is being dragged.
     */
    getItem<T>(): T,

    /**
     * Returns a plain object representing the last recorded drop result. The drop targets may optionally specify it by returning an object from their
     * drop() methods. When a chain of drop() is dispatched for the nested targets, bottom up, any parent that explicitly returns its own result from drop()
     * overrides the child drop result previously set by the child. Returns null if called outside endDrag().
     */
    getDropResult<T>(): T | null,

    /**
     * Returns true if some drop target has handled the drop event, false otherwise. Even if a target did not return a drop result, didDrop() returns true.
     * Use it inside endDrag() to test whether any drop target has handled the drop. Returns false if called outside endDrag().
     */
    didDrop(): boolean,

    /**
     * Returns the { x, y } client offset of the pointer at the time when the current drag operation has started. Returns null if no item is being dragged.
     */
    getInitialClientOffset(): XYCoord | null,

    /**
     * Returns the { x, y } client offset of the drag source component's root DOM node at the time when the current drag operation has started.
     * Returns null if no item is being dragged.
     */
    getInitialSourceClientOffset(): XYCoord | null,

    /**
     * Returns the last recorded { x, y } client offset of the pointer while a drag operation is in progress. Returns null if no item is being dragged.
     */
    getClientOffset(): XYCoord | null,

    /**
     * Returns the { x, y } difference between the last recorded client offset of the pointer and the client offset when the current drag operation has started.
     * Returns null if no item is being dragged.
     */
    getDifferenceFromInitialOffset(): XYCoord | null,

    /**
     * Returns the projected { x, y } client offset of the drag source component's root DOM node, based on its position at the time when the current drag operation has
     * started, and the movement difference. Returns null if no item is being dragged.
     */
    getSourceClientOffset(): XYCoord | null,

    /**
     * Returns the ids of the potential drop targets.
     */
    getTargetIds(): Identifier[],
  };
  declare export type MonitorEventEmitter = {
    subscribeToStateChange(
      fn: () => void,
      options?: {
        handlerIds?: Identifier[],
        ...
      }
    ): Unsubscribe,
  };
  declare export type DropTargetMonitor<
    DragObject = mixed,
    DropResult = mixed
  > = {
    ...$Exact<HandlerManager>,
    ...$Exact<MonitorEventEmitter>,

    /**
     * Returns true if there is a drag operation in progress, and the owner's canDrop() returns true or is not defined.
     */
    canDrop(): boolean,

    /**
     * Returns true if there is a drag operation in progress, and the pointer is currently hovering over the owner.
     * You may optionally pass { shallow: true } to strictly check whether only the owner is being hovered, as opposed
     * to a nested target.
     */
    isOver(options?: {
      shallow?: boolean,
      ...
    }): boolean,

    /**
     * Returns a string or a symbol identifying the type of the current dragged item. Returns null if no item is being dragged.
     */
    getItemType(): Identifier | null,

    /**
     * Returns a plain object representing the currently dragged item. Every drag source must specify it by returning an object from
     * its beginDrag() method. Returns null if no item is being dragged.
     */
    getItem<T>(): T,

    /**
     * Returns a plain object representing the last recorded drop result. The drop targets may optionally specify it by returning an
     * object from their drop() methods. When a chain of drop() is dispatched for the nested targets, bottom up, any parent that explicitly
     * returns its own result from drop() overrides the drop result previously set by the child. Returns null if called outside drop().
     */
    getDropResult<T>(): T | null,

    /**
     * Returns true if some drop target has handled the drop event, false otherwise. Even if a target did not return a drop result,
     * didDrop() returns true. Use it inside drop() to test whether any nested drop target has already handled the drop. Returns false
     * if called outside drop().
     */
    didDrop(): boolean,

    /**
     * Returns the { x, y } client offset of the pointer at the time when the current drag operation has started. Returns null if no item
     * is being dragged.
     */
    getInitialClientOffset(): XYCoord | null,

    /**
     * Returns the { x, y } client offset of the drag source component's root DOM node at the time when the current drag operation has started.
     * Returns null if no item is being dragged.
     */
    getInitialSourceClientOffset(): XYCoord | null,

    /**
     * Returns the last recorded { x, y } client offset of the pointer while a drag operation is in progress. Returns null if no item is being dragged.
     */
    getClientOffset(): XYCoord | null,

    /**
     * Returns the { x, y } difference between the last recorded client offset of the pointer and the client offset when current the drag operation has
     * started. Returns null if no item is being dragged.
     */
    getDifferenceFromInitialOffset(): XYCoord | null,

    /**
     * Returns the projected { x, y } client offset of the drag source component's root DOM node, based on its position at the time when the current
     * drag operation has started, and the movement difference. Returns null if no item is being dragged.
     */
    getSourceClientOffset(): XYCoord | null,
  };
  declare export type DragLayerMonitor = {
    /**
     * Returns true if a drag operation is in progress. Returns false otherwise.
     */
    isDragging(): boolean,

    /**
     * Returns a string or a symbol identifying the type of the current dragged item.
     * Returns null if no item is being dragged.
     */
    getItemType(): Identifier | null,

    /**
     * Returns a plain object representing the currently dragged item.
     * Every drag source must specify it by returning an object from its beginDrag() method.
     * Returns null if no item is being dragged.
     */
    getItem(): any,

    /**
     * Returns the { x, y } client offset of the pointer at the time when the current drag operation has started.
     * Returns null if no item is being dragged.
     */
    getInitialClientOffset(): XYCoord | null,

    /**
     * Returns the { x, y } client offset of the drag source component's root DOM node at the time when the current
     * drag operation has started. Returns null if no item is being dragged.
     */
    getInitialSourceClientOffset(): XYCoord | null,

    /**
     * Returns the last recorded { x, y } client offset of the pointer while a drag operation is in progress.
     * Returns null if no item is being dragged.
     */
    getClientOffset(): XYCoord | null,

    /**
     * Returns the { x, y } difference between the last recorded client offset of the pointer and the client
     * offset when current the drag operation has started. Returns null if no item is being dragged.
     */
    getDifferenceFromInitialOffset(): XYCoord | null,

    /**
     * Returns the projected { x, y } client offset of the drag source component's root DOM node, based on its
     * position at the time when the current drag operation has started, and the movement difference.
     * Returns null if no item is being dragged.
     */
    getSourceClientOffset(): XYCoord | null,
  };

  declare export type DragSourceOptions = {
    /**
     * Optional. A string. By default, 'move'. In the browsers that support this feature, specifying 'copy'
     * shows a special “copying” cursor, while 'move' corresponds to the “move” cursor. You might want to use
     * this option to provide a hint to the user about whether an action is destructive.
     */
    dropEffect?: string,
  };
  declare export type DragPreviewOptions = {
    /**
     * Optional. A boolean. By default, false. If true, the component will learn that it is being dragged immediately as the drag
     * starts instead of the next tick. This means that the screenshotting would occur with monitor.isDragging() already being true,
     * and if you apply any styling like a decreased opacity to the dragged element, this styling will also be reflected on the
     * screenshot. This is rarely desirable, so false is a sensible default. However, you might want to set it to true in rare cases,
     * such as if you want to make the custom drag layers work in IE and you need to hide the original element without resorting to
     * an empty drag preview which IE doesn't support.
     */
    captureDraggingState?: boolean,

    /**
     * Optional. A number between 0 and 1. By default, 0.5. Specifies how the offset relative to the drag source node is translated
     * into the horizontal offset of the drag preview when their sizes don't match. 0 means “dock the preview to the left”, 0.5 means
     * “interpolate linearly” and 1 means “dock the preview to the right”.
     */
    anchorX?: number,

    /**
     * Optional. A number between 0 and 1. By default, 0.5. Specifies how the offset relative to the drag source node is translated into
     * the vertical offset of the drag preview when their sizes don't match. 0 means “dock the preview to the top, 0.5 means “interpolate
     * linearly” and 1 means “dock the preview to the bottom.
     */
    anchorY?: number,

    /**
     * Optional. A number or null if not needed. By default, null. Specifies the vertical offset between the cursor and the drag preview
     * element. If offsetX has a value, anchorX won't be used.
     */
    offsetX?: number,

    /**
     * Optional. A number or null if not needed. By default, null. Specifies the vertical offset between the cursor and the drag
     * preview element. If offsetY has a value, anchorY won't be used.
     */
    offsetY?: number,
  };
  declare export type DropTargetOptions = any;

  declare export type ConnectableElement =
    | React$Ref<any>
    | React$ElementType
    | Element
    | null;
  declare export type DragElementWrapper<Options> = (
    elementOrNode: ConnectableElement,
    options?: Options
  ) => React$ElementType | null;
  declare export type ConnectDragSource = DragElementWrapper<DragSourceOptions>;
  declare export type ConnectDropTarget = DragElementWrapper<any>;
  declare export type ConnectDragPreview = DragElementWrapper<DragPreviewOptions>;

  /**
   * The React context type
   */
  declare export type DndContextType = {
    dragDropManager: DragDropManager | void,
  };

  /**
   * Create the React Context
   */
  declare export var DndContext: $PropertyType<$Exports<"react">, "Context">;

  declare export type DndProviderProps<BackendContext, BackendOptions> =
    | {
        manager: DragDropManager,
        ...
      }
    | {
        backend: BackendFactory,
        context?: BackendContext,
        options?: BackendOptions,
        debugMode?: boolean,
        ...
      };
  /**
   * A React component that provides the React-DnD context
   */
  declare export var DndProvider: React$StatelessFunctionalComponent<
    DndProviderProps<mixed, mixed>
  >;

  declare export type DragPreviewImageProps = {
    connect: ConnectDragPreview,
    src: string,
  };

  /**
   * A utility for rendering a drag preview image
   */
  declare export var DragPreviewImage: React$StatelessFunctionalComponent<DragPreviewImageProps>;

  /**
   * Flowtype definitions for types
   * Generated by Flowgen from a Typescript Definition
   * Flowgen v1.14.1
   */

  import type { Component, ComponentType /* ComponentClass */ } from "react";
  /* TODO */
  // import type { NonReactStatics } from "hoist-non-react-statics";

  /**
   * Options for the Drag Sources, Drop Targets, and Drag Layers decorators
   */
  declare export type DndOptions<Props> = {
    arePropsEqual?: (first: Props, second: Props) => boolean,
  };

  /**
   * A DnD interactive component
   */
  declare export type DndComponent<Props> = {
    ...$Exact<Component<Props>>,

    getDecoratedComponentInstance(): Component<Props> | null,
    getHandlerId(): Identifier,
  };

  /**
   * Interface for the DropTarget specification object
   */
  declare export type DropTargetSpec<
    Props,
    DragObject = any,
    DropResult = any
  > = {
    /**
     * Optional.
     * Called when a compatible item is dropped on the target. You may either return undefined, or a plain object.
     * If you return an object, it is going to become the drop result and will be available to the drag source in its
     * endDrag method as monitor.getDropResult(). This is useful in case you want to perform different actions
     * depending on which target received the drop. If you have nested drop targets, you can test whether a nested
     * target has already handled drop by checking monitor.didDrop() and monitor.getDropResult(). Both this method and
     * the source's endDrag method are good places to fire Flux actions. This method will not be called if canDrop()
     * is defined and returns false.
     */
    drop?: (
      props: Props,
      monitor: DropTargetMonitor<DragObject, DropResult>,
      component: any
    ) => DropResult | void,

    /**
     * Optional.
     * Called when an item is hovered over the component. You can check monitor.isOver({ shallow: true }) to test whether
     * the hover happens over just the current target, or over a nested one. Unlike drop(), this method will be called even
     * if canDrop() is defined and returns false. You can check monitor.canDrop() to test whether this is the case.
     */
    hover?: (
      props: Props,
      monitor: DropTargetMonitor<DragObject, DropResult>,
      component: any
    ) => void,

    /**
     * Optional. Use it to specify whether the drop target is able to accept the item. If you want to always allow it, just
     * omit this method. Specifying it is handy if you'd like to disable dropping based on some predicate over props or
     * monitor.getItem(). Note: You may not call monitor.canDrop() inside this method.
     */
    canDrop?: (
      props: Props,
      monitor: DropTargetMonitor<DragObject, DropResult>
    ) => boolean,
  };
  declare export type DragSourceSpec<
    Props,
    DragObject = any,
    DropResult = any
  > = {
    /**
     * Required.
     * When the dragging starts, beginDrag is called. You must return a plain JavaScript object describing the
     * data being dragged. What you return is the only information available to the drop targets about the drag
     * source so it's important to pick the minimal data they need to know. You may be tempted to put a reference
     * to the component into it, but you should try very hard to avoid doing this because it couples the drag
     * sources and drop targets. It's a good idea to return something like { id: props.id } from this method.
     */
    beginDrag: (
      props: Props,
      monitor: DragSourceMonitor<DragObject, DropResult>,
      component: any
    ) => DragObject,

    /**
     * Optional.
     * When the dragging stops, endDrag is called. For every beginDrag call, a corresponding endDrag call is guaranteed.
     * You may call monitor.didDrop() to check whether or not the drop was handled by a compatible drop target. If it was handled,
     * and the drop target specified a drop result by returning a plain object from its drop() method, it will be available as
     * monitor.getDropResult(). This method is a good place to fire a Flux action. Note: If the component is unmounted while dragging,
     * component parameter is set to be null.
     */
    endDrag?: (
      props: Props,
      monitor: DragSourceMonitor<DragObject, DropResult>,
      component: any
    ) => void,

    /**
     * Optional.
     * Use it to specify whether the dragging is currently allowed. If you want to always allow it, just omit this method.
     * Specifying it is handy if you'd like to disable dragging based on some predicate over props. Note: You may not call
     * monitor.canDrag() inside this method.
     */
    canDrag?: (
      props: Props,
      monitor: DragSourceMonitor<DragObject, DropResult>
    ) => boolean,

    /**
     * Optional.
     * By default, only the drag source that initiated the drag operation is considered to be dragging. You can
     * override this behavior by defining a custom isDragging method. It might return something like props.id === monitor.getItem().id.
     * Do this if the original component may be unmounted during the dragging and later “resurrected” with a different parent.
     * For example, when moving a card across the lists in a Kanban board, you want it to retain the dragged appearance—even though
     * technically, the component gets unmounted and a different one gets mounted every time you move it to another list.
     *
     * Note: You may not call monitor.isDragging() inside this method.
     */
    isDragging?: (
      props: Props,
      monitor: DragSourceMonitor<DragObject, DropResult>
    ) => boolean,
  };

  /**
   * DragSourceConnector is an object passed to a collecting function of the DragSource.
   * Its methods return functions that let you assign the roles to your component's DOM nodes.
   */
  declare export type DragSourceConnector = {
    /**
     * Returns a function that must be used inside the component to assign the drag source role to a node. By
     * returning { connectDragSource: connect.dragSource() } from your collecting function, you can mark any React
     * element as the draggable node. To do that, replace any element with this.props.connectDragSource(element) inside
     * the render function.
     */
    dragSource(): ConnectDragSource,

    /**
     * Optional. Returns a function that may be used inside the component to assign the drag preview role to a node. By
     * returning { connectDragPreview: connect.dragPreview() } from your collecting function, you can mark any React element
     * as the drag preview node. To do that, replace any element with this.props.connectDragPreview(element) inside the render
     * function. The drag preview is the node that will be screenshotted by the HTML5 backend when the drag begins. For example,
     * if you want to make something draggable by a small custom handle, you can mark this handle as the dragSource(), but also
     * mark an outer, larger component node as the dragPreview(). Thus the larger drag preview appears on the screenshot, but
     * only the smaller drag source is actually draggable. Another possible customization is passing an Image instance to dragPreview
     * from a lifecycle method like componentDidMount. This lets you use the actual images for drag previews. (Note that IE does not
     * support this customization). See the example code below for the different usage examples.
     */
    dragPreview(): ConnectDragPreview,
  };

  /**
   * DropTargetConnector is an object passed to a collecting function of the DropTarget. Its only method dropTarget() returns a function
   * that lets you assign the drop target role to one of your component's DOM nodes.
   */
  declare export type DropTargetConnector = {
    /**
     * Returns a function that must be used inside the component to assign the drop target role to a node.
     * By returning { connectDropTarget: connect.dropTarget() } from your collecting function, you can mark any React element
     * as the droppable node. To do that, replace any element with this.props.connectDropTarget(element) inside the render function.
     */
    dropTarget(): ConnectDropTarget,
  };
  declare export type DragSourceCollector<CollectedProps, TargetProps> = (
    connect: DragSourceConnector,
    monitor: DragSourceMonitor<>,
    props: TargetProps
  ) => CollectedProps;
  declare export type DropTargetCollector<CollectedProps, TargetProps> = (
    connect: DropTargetConnector,
    monitor: DropTargetMonitor<>,
    props: TargetProps
  ) => CollectedProps;
  declare export type DragLayerCollector<TargetProps, CollectedProps> = (
    monitor: DragLayerMonitor,
    props: TargetProps
  ) => CollectedProps;

  /* TODO */
  // declare export type Omit<T, K: $Keys<T>> = Pick<T, Exclude<$Keys<T>, K>>;
  declare export type Omit<T, K: $Keys<T>> = any;

  /**
   * A property P will be present if:
   * - it is present in DecorationTargetProps
   *
   * Its value will be dependent on the following conditions
   * - if property P is present in InjectedProps and its definition extends the definition
   *   in DecorationTargetProps, then its definition will be that of DecorationTargetProps[P]
   * - if property P is not present in InjectedProps then its definition will be that of
   *   DecorationTargetProps[P]
   * - if property P is present in InjectedProps but does not extend the
   *   DecorationTargetProps[P] definition, its definition will be that of InjectedProps[P]
   */
  declare export type Matching<InjectedProps, DecorationTargetProps> = $ObjMapi<
    DecorationTargetProps,
    <P>(
      P
    ) => /* Flow doesn't support conditional types, use `$Call` utility type */ any
  >;
  /**
   * a property P will be present if :
   * - it is present in both DecorationTargetProps and InjectedProps
   * - InjectedProps[P] can satisfy DecorationTargetProps[P]
   * ie: decorated component can accept more types than decorator is injecting
   *
   * For decoration, inject props or ownProps are all optionally
   * required by the decorated (right hand side) component.
   * But any property required by the decorated component must be satisfied by the injected property.
   */
  declare export type Shared<InjectedProps, DecorationTargetProps> = $ObjMapi<
    /* TODO */
    /* { [k: Extract<$Keys<InjectedProps>, $Keys<DecorationTargetProps>>]: any } */
    any,
    <P>(
      P
    ) => /* Flow doesn't support conditional types, use `$Call` utility type */ any
  >;
  /**
   * Gets the props interface of a component using inference
   */
  declare export type GetProps<
    C
  > = /* Flow doesn't support conditional types, use `$Call` utility type */ any;
  declare export type DndComponentEnhancer<CollectedProps> = <
    C /* TODO */ /* ComponentType<Matching<CollectedProps, GetProps<C>>> */
  >(
    component: C
  ) => DndComponentClass<
    C,
    Omit<GetProps<C>, $Keys<Shared<CollectedProps, GetProps<C>>>>
  >;
  declare export type DndComponentClass<C: ComponentType<any>, P> =
    /* TODO */
    /* {
    ...ComponentClass<JSX.LibraryManagedAttributes<C, P>>,
    ...NonReactStatics<C>,
    ...{
      DecoratedComponent: C,
      ...
    },
  }; */
    any;

  /**
   * Decorates a component as a dragsource
   * @param type The dragsource type
   * @param spec The drag source specification
   * @param collect The props collector function
   * @param options DnD options
   */
  declare export function DragSource<
    RequiredProps,
    CollectedProps,
    DragObject,
    DropResult
  >(
    type: SourceType | ((props: RequiredProps) => SourceType),
    spec: DragSourceSpec<RequiredProps, DragObject, DropResult>,
    collect: DragSourceCollector<CollectedProps, RequiredProps>,
    options?: DndOptions<RequiredProps>
  ): DndComponentEnhancer<CollectedProps>;

  /**
   * @param type The accepted target type
   * @param spec The DropTarget specification
   * @param collect The props collector function
   * @param options Options
   */
  declare export function DropTarget<
    RequiredProps,
    CollectedProps,
    DragObject,
    DropResult
  >(
    type: TargetType | ((props: RequiredProps) => TargetType),
    spec: DropTargetSpec<RequiredProps, DragObject, DropResult>,
    collect: DropTargetCollector<CollectedProps, RequiredProps>,
    options?: DndOptions<RequiredProps>
  ): DndComponentEnhancer<CollectedProps>;

  /**
   * @param collect The props collector function
   * @param options The DnD options
   */
  declare export function DragLayer<RequiredProps, CollectedProps>(
    collect: DragLayerCollector<RequiredProps, CollectedProps>,
    options?: DndOptions<RequiredProps>
  ): DndComponentEnhancer<CollectedProps>;

  /**
   * Flowtype definitions for types
   * Generated by Flowgen from a Typescript Definition
   * Flowgen v1.14.1
   */

  declare export type FactoryOrInstance<T> = T | (() => T);
  declare export type DragObjectFactory<T> = (
    monitor: DragSourceMonitor<T>
  ) => T | null;
  declare export type DragSourceHookSpec<
    DragObject,
    DropResult,
    CollectedProps
  > = {
    /**
     * The type of item being dragged. This is required when using the function form of spec.item.
     * If spec.item is a static object, the type may either be defined on that object as `item.type`, or it may
     * be defined here.
     */
    type: SourceType,

    /**
     * This property generates or defines a plain javascript item describing
     * the data being dragged. This is the only information available to the
     * drop targets about the drag source so it's important to pick the minimal
     * data they need to know.
     *
     * You may be tempted to put a reference to the component or complex object here,
     * but you should try very hard to avoid doing this because it couples the
     * drag sources and drop targets. It's a good idea to use something like
     * { id: props.id }
     *
     * If a function-form is used, it is invoked when the drag begins and returns a draggable item.
     * If the function returns null, the drag is canceled
     */
    item?: DragObject | DragObjectFactory<DragObject>,

    /**
     * The drag source options
     */
    options?: DragSourceOptions,

    /**
     * DragPreview options
     */
    previewOptions?: DragPreviewOptions,

    /**
     * Optional.
     * When the dragging stops, endDrag is called. For every beginDrag call, a corresponding endDrag call is guaranteed.
     * You may call monitor.didDrop() to check whether or not the drop was handled by a compatible drop target. If it was handled,
     * and the drop target specified a drop result by returning a plain object from its drop() method, it will be available as
     * monitor.getDropResult(). This method is a good place to fire a Flux action. Note: If the component is unmounted while dragging,
     * component parameter is set to be null.
     */
    end?: (
      draggedItem: DragObject,
      monitor: DragSourceMonitor<DragObject, DropResult>
    ) => void,

    /**
     * Optional.
     * Use it to specify whether the dragging is currently allowed. If you want to always allow it, just omit this method.
     * Specifying it is handy if you'd like to disable dragging based on some predicate over props. Note: You may not call
     * monitor.canDrag() inside this method.
     */
    canDrag?:
      | boolean
      | ((monitor: DragSourceMonitor<DragObject, DropResult>) => boolean),

    /**
     * Optional.
     * By default, only the drag source that initiated the drag operation is considered to be dragging. You can
     * override this behavior by defining a custom isDragging method. It might return something like props.id === monitor.getItem().id.
     * Do this if the original component may be unmounted during the dragging and later “resurrected” with a different parent.
     * For example, when moving a card across the lists in a Kanban board, you want it to retain the dragged appearance—even though
     * technically, the component gets unmounted and a different one gets mounted every time you move it to another list.
     *
     * Note: You may not call monitor.isDragging() inside this method.
     */
    isDragging?: (
      monitor: DragSourceMonitor<DragObject, DropResult>
    ) => boolean,

    /**
     * A function to collect rendering properties
     */
    collect?: (
      monitor: DragSourceMonitor<DragObject, DropResult>
    ) => CollectedProps,
  };

  /**
   * Interface for the DropTarget specification object
   */
  declare export type DropTargetHookSpec<
    DragObject,
    DropResult,
    CollectedProps
  > = {
    /**
     * The kinds of dragItems this dropTarget accepts
     */
    accept: TargetType,

    /**
     * The drop target options
     */
    options?: DropTargetOptions,

    /**
     * Optional.
     * Called when a compatible item is dropped on the target. You may either return undefined, or a plain object.
     * If you return an object, it is going to become the drop result and will be available to the drag source in its
     * endDrag method as monitor.getDropResult(). This is useful in case you want to perform different actions
     * depending on which target received the drop. If you have nested drop targets, you can test whether a nested
     * target has already handled drop by checking monitor.didDrop() and monitor.getDropResult(). Both this method and
     * the source's endDrag method are good places to fire Flux actions. This method will not be called if canDrop()
     * is defined and returns false.
     */
    drop?: (
      item: DragObject,
      monitor: DropTargetMonitor<>
    ) => DropResult | void,

    /**
     * Optional.
     * Called when an item is hovered over the component. You can check monitor.isOver({ shallow: true }) to test whether
     * the hover happens over just the current target, or over a nested one. Unlike drop(), this method will be called even
     * if canDrop() is defined and returns false. You can check monitor.canDrop() to test whether this is the case.
     */
    hover?: (item: DragObject, monitor: DropTargetMonitor<>) => void,

    /**
     * Optional. Use it to specify whether the drop target is able to accept the item. If you want to always allow it, just
     * omit this method. Specifying it is handy if you'd like to disable dropping based on some predicate over props or
     * monitor.getItem(). Note: You may not call monitor.canDrop() inside this method.
     */
    canDrop?: (item: DragObject, monitor: DropTargetMonitor<>) => boolean,

    /**
     * A function to collect rendering properties
     */
    collect?: (monitor: DropTargetMonitor<>) => CollectedProps,
  };

  /**
   * useDragSource hook
   * @param sourceSpec The drag source specification (object or function, function preferred)
   * @param deps The memoization deps array to use when evaluating spec changes
   */
  declare export function useDrag<DragObject, DropResult, CollectedProps>(
    specArg: FactoryOrInstance<
      DragSourceHookSpec<DragObject, DropResult, CollectedProps>
    >,
    deps?: mixed[]
  ): [CollectedProps, ConnectDragSource, ConnectDragPreview];

  /**
   * useDropTarget Hook
   * @param spec The drop target specification (object or function, function preferred)
   * @param deps The memoization deps array to use when evaluating spec changes
   */
  declare export function useDrop<DragObject, DropResult, CollectedProps>(
    specArg: FactoryOrInstance<
      DropTargetHookSpec<DragObject, DropResult, CollectedProps>
    >,
    deps?: mixed[]
  ): [CollectedProps, ConnectDropTarget];

  /**
   * useDragLayer Hook
   * @param collector The property collector
   */
  declare export function useDragLayer<CollectedProps>(
    collect: (monitor: DragLayerMonitor) => CollectedProps
  ): CollectedProps;

  /**
   * A hook to retrieve the DragDropManager from Context
   */
  declare export function useDragDropManager(): DragDropManager;
}
